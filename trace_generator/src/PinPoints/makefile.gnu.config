# These definitions are generated by the kit builder
KIT=1
TARGET_OS=l

##############################################################
#
# Here are some things you might want to configure
#
##############################################################


# if your tool is not in the kit directory
# then set this to the pin-2.0-X-Y directory
PIN_HOME ?= ..

# Select static or dynamic linking for tool
# only applies to unix
#PIN_DYNAMIC = -static
PIN_DYNAMIC = -ldl

##############################################################
#
# Typical users will not need to change the stuff below here
#
##############################################################

##############################################################
# Set things for all architectures and all OS
##############################################################
ifeq ($(DEBUG),1)
  OPT  =
  DBG = -g
else
  DBG =
  OPT  = -O3 -fomit-frame-pointer
endif

DBG_INFO_ALWAYS = -g -O0

PIN_CXXFLAGS   = -DBIGARRAY_MULTIPLIER=1 -DUSING_XED $(DBG)
PIN_CXXFLAGS  += -fno-strict-aliasing -I$(PIN_HOME)/Include -I$(PIN_HOME)/InstLib
PIN_LPATHS     = -L$(PIN_ROOT)/$(TARGET)/runtime/pincrt \
                   -L$(PIN_ROOT)/$(TARGET)/lib \
                   -L$(PIN_ROOT)/$(TARGET)/lib-ext \
                   $(PIN_KIT)/$(TARGET)/runtime/pincrt/crtendS.o
PIN_BASE_LIBS :=
PIN_LDFLAGS    = $(DBG)
NO_LOGO        =
SSE2           = -msse2
ifdef ICC
    ICC_NO_SSE = -mia32
endif
ENABLE_VS      = 0
PROBE          = 1
AS_FLAGS       =
ASLD_FLAGS     =
COMPARE_EXT    = compare
APP_LIB_ATOMIC := -latomic

ifeq ($(CCOV),1)
  # code coverage is on
  ifeq ($(findstring "cc/10.",$(ICCDIR)),)
    # icc version >= 11
    PIN_LDFLAGS += -prof-gen=srcpos
  else
    # icc version 10
    PIN_LDFLAGS += -prof-genx
  endif
  ifneq ($(CCOVDIR),)
    PIN_LDFLAGS += -prof-dir $(CCOVDIR)
  endif
endif

ifeq ($(ENABLE_VS),1)
    VIRT_SEG_FLAG  = -xyzzy -241runtime 0 -xyzzy -virtual_segments 1
else
    VIRT_SEG_FLAG  =
endif

ifndef HOST_ARCH
    # default to building for the host you are on. You can override this on the cmd line.
    HST=$(shell uname -m)
    ifeq (${HST},x86_64)
        HOST_ARCH=ia32e
    endif
    ifeq (${HST},amd64)
        HOST_ARCH=ia32e
    endif
    ifeq (${HST},i686)
        HOST_ARCH=ia32
    endif
    ifeq (${HST},x86)
        HOST_ARCH=ia32
    endif
    ifeq (${HST},i386)
        HOST_ARCH=ia32
    endif
    ifeq (${HST},ia64)
        HOST_ARCH=ipf
    endif
endif

ifndef HOST_ARCH
    $(error could not detect building host. please define HOST_ARCH on the command line)
endif

ifndef TARGET
    TARGET=${HOST_ARCH}
endif

#define TARGET_LONG
ifeq (${TARGET},ia32e)
    TARGET_LONG=intel64
endif
ifeq (${TARGET},ia32)
    TARGET_LONG=ia32
endif
ifeq (${TARGET},mic)
    TARGET_LONG=mic
endif
ifeq (${TARGET},ipf)
    TARGET_LONG=ia64
endif
ifndef TARGET_LONG
    $(error unknown TARGET, could not define TARGET_LONG)
endif

##############################################################
# Set the kit versus source tree stuff
##############################################################
ifndef KIT
    KIT = 0
endif
ifndef OVERRIDE_DEFAULT_COMPILER
    OVERRIDE_DEFAULT_COMPILER = 0
endif

OS=$(shell uname -s)
ifeq ($(findstring CYGWIN,$(OS)),CYGWIN)
    BUILD_OS = w
    TARGET_OS = w
    TARGET_OS_LONG = windows
else
    ifeq ($(OS),Darwin)
        BUILD_OS = m
        TARGET_OS = m
        TARGET_OS_LONG = mac
    else
        ifeq ($(OS),FreeBSD)
          BUILD_OS = b
          TARGET_OS = b
          TARGET_OS_LONG = bsd
        else
          BUILD_OS = l
          TARGET_OS = l
          TARGET_OS_LONG = linux
      endif
    endif
endif

# Attach-Detach tests are not supported on all OSes
# ATTACH feature is not supported on 2.4 because there is no /proc/pid/task
# on this system that gives the list of threads

# Linux kernel 2.6.18-1.2798.fc6 has a bug in ptrace_detach which don't reset single-step flag

OSREL=$(shell uname -r)
NO_ATTACH_TESTS_OS = 2.4

ATTACH_SUPPORTED = yes
DETACH_SUPPORTED = yes

ifeq ($(findstring $(NO_ATTACH_TESTS_OS),$(OSREL)),$(NO_ATTACH_TESTS_OS))
    ATTACH_SUPPORTED = no
endif


PIN = $(PIN_NOFLAGS) $(PIN_TEST_FLAGS)
PIN_TEST_FLAGS = -slow_asserts $(VIRT_SEG_FLAG) $(PIN_FLAGS) $(PIN_USERFLAGS)

ifeq (${KIT},0)

    #
    # Building out of a source tree
    #

    ifeq (${TARGET},ia32e)
         TARGET_EXT = ia32_intel64
    else
         TARGET_EXT = $(TARGET_LONG)
    endif

    # If you are building out of a source tree and not a kit
    # point this to the charm directory
    PIN_ROOT ?= ../..

    # The name of some source tree directories are different depending on whether Pin was
    # built with ICC, GCC, or CLANG.
    ifneq ($(ICCPIN),)
        COMPILER = icc
    else
        ifeq ($(TARGET_OS),m)
            COMPILER = clang
        else
            ifeq ($(TARGET),mic)
                COMPILER = icc
            else
                COMPILER = gcc
            endif
        endif
    endif

    XEDKIT = $(PIN_ROOT)/build/Source/xed/xed-$(COMPILER)-pin-$(TARGET_OS_LONG)-$(TARGET_LONG)/xed-kit
    PINKIT = $(PIN_ROOT)/build/Source/pin/pin-W-X-Y-$(TARGET_EXT)-$(TARGET_OS_LONG)
    APP_CXXFLAGS  += -I$(PIN_ROOT)/Source/atomic/00-export-include \
                     -I$(PIN_ROOT)/Source/barecrt/00-export-include \
                     -I$(PIN_ROOT)/Source/fund/00-export-include \
                     -I$(PIN_ROOT)/Source/sync/00-export-include \
                     -I$(PIN_ROOT)/Source/util/00-export-include \
                     -L$(PINKIT)/extras/components/lib/$(TARGET_LONG)
    APP_CXXFLAGS2 += -I$(PIN_ROOT)/Source/atomic/00-export-include \
                     -I$(PIN_ROOT)/Source/barecrt/00-export-include \
                     -I$(PIN_ROOT)/Source/fund/00-export-include \
                     -I$(PIN_ROOT)/Source/sync/00-export-include \
                     -I$(PIN_ROOT)/Source/util/00-export-include \
                     -L$(PINKIT)/extras/components/lib/$(TARGET_LONG)

    PIN_CXXFLAGS += -I$(XEDKIT)/include \
                    -I$(PIN_ROOT)/Source/atomic/00-export-include \
                    -I$(PIN_ROOT)/Source/barecrt/00-export-include \
                    -I$(PIN_ROOT)/Source/fund/00-export-include \
                    -I$(PIN_ROOT)/Source/sync/00-export-include \
                    -I$(PIN_ROOT)/Source/util/00-export-include \
                    -I$(PINKIT)/source/include/pin/gen \
                    -I$(PINKIT)/source/include \
		    -I$(PINKIT)/source/include/pin

    # When cross-building an ia32 tool on an ia32e host, the Pin headers could be in either of two possible places.
    # If only the ia32 Pin kit was built, the headers are in the location specified above.  However, if the combined
    # Pin kit was built, they are in the location specified below.
    ifeq (${TARGET}-${HOST_ARCH},ia32-ia32e)
        PINKIT2 = $(PIN_ROOT)/build/Source/pin/pin-W-X-Y-ia32_intel64-$(TARGET_OS_LONG)
        PIN_CXXFLAGS += -I$(PINKIT2)/source/include/pin/ -I$(PINKIT2)/source/include/pin/gen -I$(PINKIT2)/source/include
        APP_CXXFLAGS += -L$(PINKIT2)/extras/components/lib/$(TARGET_LONG)
        APP_CXXFLAGS2 += -L$(PINKIT2)/extras/components/lib/$(TARGET_LONG)
    endif

    TARGET_SPEC = ${TARGET_LONG}_${TARGET_OS_LONG}${TARGET_OFORMAT}
    PIN_LPATHS +=  -L$(PIN_ROOT)/build/Source/pin/pin-${TARGET_OS_LONG}-${TARGET_LONG} \
                   -L$(PIN_ROOT)/External/Libdwarf/Lib_${TARGET_SPEC} \
                   -L$(PIN_ROOT)/External/Libelf/Lib_${TARGET_SPEC} \
                   -L$(XEDKIT)/lib
    PIN_LIBNAMES =  $(PIN_ROOT)/build/Source/pin/pin-${TARGET_OS_LONG}-${TARGET_LONG}/libpin.a

    PINDB =  $(PIN_ROOT)/build/Source/pindb/export-${TARGET_OS_LONG}-${TARGET_LONG}/pindb
    PINDB_LIBPATH =
    PINDB_WITH_LIBPATH = $(PINDB)

    ifeq (${TARGET_OS_LONG}-${TARGET_LONG},linux-ia32)
        PIN_EXE = $(PIN_ROOT)/Source/pin/pin-runner-linux-ia32.sh
    else
    ifeq (${TARGET_OS_LONG}-${TARGET_LONG},linux-intel64)
        PIN_EXE = $(PIN_ROOT)/Source/pin/pin-runner-linux-intel64.sh
    else
        PIN_EXE = $(PIN_ROOT)/build/Source/pin/pin-${TARGET_OS_LONG}-${TARGET_LONG}/pin
        LAUNCHER_EXE = $(PIN_ROOT)/build/Source/pin/pin-${TARGET_OS_LONG}-${TARGET_LONG}/runpin
    endif
    endif
    PIN_NOFLAGS = $(PIN_EXE)

    ifeq (${TARGET_OS_LONG},linux)
        PIN_EXE_32 = $(PIN_ROOT)/build/Source/pin/pin-${TARGET_OS_LONG}-ia32/pin
        PIN_EXE_64 = $(PIN_ROOT)/build/Source/pin/pin-${TARGET_OS_LONG}-intel64/pin
        LAUNCHER_EXE = $(PIN_ROOT)/build/Source/pin/pin-${TARGET_OS_LONG}-intel64/runpin
    endif

    OVERRIDE_DEFAULT_COMPILER = 1

    VSCRIPT_DIR = $(PIN_HOME)/Include/pin/
else

    #
    # Building out of a kit
    #
    PIN_KIT ?= ../../..

    PINDB_LIBPATH = $(PIN_KIT)/$(TARGET_LONG)/runtime

    ifeq (${TARGET_OS},l)
        TARGET_OS_LONG=linux
        REQUIRES_PIN_CPP_RUNTIME=$(shell $(PIN_KIT)/source/tools/testGccVersion $(CXX) 4.5)
        ifeq (${REQUIRES_PIN_CPP_RUNTIME},1)
            PIN_LPATHS += -L$(PIN_KIT)/$(TARGET_LONG)/runtime/cpplibs
            PIN_LDFLAGS += -Wl,-rpath=$(PIN_KIT)/$(TARGET_LONG)/runtime/cpplibs
            PINDB_LIBPATH = $(PIN_KIT)/$(TARGET_LONG)/runtime:$(PIN_KIT)/$(TARGET_LONG)/runtime/cpplibs
        else
            PINDB_LIBPATH = $(PIN_KIT)/$(TARGET_LONG)/runtime
        endif
    endif
    ifeq (${TARGET_OS},m)
        TARGET_OS_LONG=mac
    endif
    ifeq (${TARGET_OS},w)
        TARGET_OS_LONG=windows
    endif
    ifeq (${TARGET_OS},b)
        TARGET_OS_LONG=bsd
    endif

    PIN_EXE = $(PIN_KIT)/$(TARGET_LONG)/bin/pinbin
    PIN_NOFLAGS = $(PIN_KIT)/pin
    PINDB = $(PIN_KIT)/$(TARGET_LONG)/bin/pindb
    PINDB_WITH_LIBPATH = LD_LIBRARY_PATH=$(PINDB_LIBPATH):$$LD_LIBRARY_PATH $(PINDB)

    XEDKIT        = $(PIN_KIT)/extras/xed-$(TARGET_LONG)
    PIN_LPATHS   += -L$(XEDKIT)/lib -L$(PIN_KIT)/$(TARGET_LONG)/lib -L$(PIN_KIT)/$(TARGET_LONG)/lib-ext
    PIN_CXXFLAGS += -I$(XEDKIT)/include -I$(PIN_KIT)/extras/components/include \
                    -I$(PIN_KIT)/source/include -I$(PIN_KIT)/source/include/pin/ -I$(PIN_KIT)/source/include/pin/gen \
                    -isystem $(PIN_KIT)/extras/stlport/include -isystem $(PIN_KIT)/extras/libstdc++/include \
                    -isystem $(PIN_KIT)/extras/crt/include -isystem $(PIN_KIT)/extras/crt/lnclude/arch-x86_64 -isystem $(PIN_KIT)/extras/crt/lnclude/arch-x86_64/machine \
                    -isystem $(PIN_KIT)/extras/crt/include/kernel/uapi -isystem $(PIN_KIT)/extras/crt/include/kernel/uapi/asm-x86 \
                    -I$(PIN_KIT)/extras/components/include -I$(PIN_KIT)/extras/xed-intel64/include/xed \
                    -I$(PIN_KIT)/source/tools/InstLib
    VSCRIPT_DIR = $(PIN_KIT)/source/include/pin

    APP_CXXFLAGS  += -I$(PIN_KIT)/extras/components/include -L$(PIN_KIT)/extras/components/lib/$(TARGET_LONG)
    APP_CXXFLAGS2 += -I$(PIN_KIT)/extras/components/include -L$(PIN_KIT)/extras/components/lib/$(TARGET_LONG)

endif

ifndef ICC
    ifdef ICCVER
        $(error ignoring ICCVER since ICC is not defined)
    endif
    ICCVER =
    ICC =
else
    ICC = 1
    ifndef ICCVER
        ICCVER = 11
    endif

    #Define ICCDIR according to ICCVER
    ifeq ($(ICCVER), 10)
    endif
    ifeq ($(ICCVER), 11)
        ICCDIR_32E = /usr/intel/pkgs/icc/11.1.046e/bin/intel64
        ICCDIR_32 =  /usr/intel/pkgs/icc/11.1.046/bin/ia32
    endif

    ifndef ICCDIR_32
         $(error ICCDIR_32 is not defined, define ICCDIR_32 on the command line or define valid ICCVER)
    endif
    ifeq (${TARGET},ia32e)
        ifndef ICCDIR_32E
             $(error ICCDIR_32E is not defined, define ICCDIR_32E on the command line or define valid ICCVER)
        endif
    endif
endif


ifeq ($(ICC),1)
    ifeq ($(GCCVER),)
        GCCVER = 4.4.2
    endif
    ifeq (${TARGET},ia32e)
        ICCDIR = $(ICCDIR_32E)
    else
        ICCDIR = $(ICCDIR_32)
    endif
    CXX = $(ICCDIR)/icpc
    CC = $(ICCDIR)/icc
    COMPARE_EXT = compareICC

    # When compiling with ICC, we need to add reference to GCC version.
    ICC_FLAGS = -i_static -Wl,-rpath=/usr/intel/pkgs/gcc/$(GCCVER)/lib
    ICC_FLAGS += -Qlocation,gld,/usr/intel/pkgs/gcc/$(GCCVER)/bin
    ICC_FLAGS += -gcc-name=/usr/intel/pkgs/gcc/$(GCCVER)/bin/gcc
    ICC_FLAGS += -gxx-name=/usr/intel/pkgs/gcc/$(GCCVER)/bin/g++

    # Enable ICC optimizations
    # ICC splits the called function into 2 different funcs - the actual func that using nonconventional
    # calling standard (args passed in regs), and a func which handle standard calling convention (pass
    # args to regs). Pin is trying to change the last func. To avoid this we disable inter-procedural
    # optimizations. Maybe in ICC 12 we could use -opt-args-in-reg=none
    ICC_FLAGS += -O2 -fno-inline -no-ip
    OPT  =

    # Add ICC flags to all compilation and linkage flags
    APP_CXXLINK_FLAGS += $(ICC_FLAGS)
    APP_CXXFLAGS += $(ICC_FLAGS) -fno-inline
    PIN_LDFLAGS += $(ICC_FLAGS)
    PIN_CXXFLAGS += $(ICC_FLAGS)

    # Disable warnings
    PIN_CXXFLAGS += -wd1418 -wd1419 -wd981 -wd383 -wd869 -wd593 -wd266 -wd279 -wd444 -wd168 -wd810 -wd810 -wd181
    PIN_CXXFLAGS += -wd1195 -wd168 -wd193
endif

# No effect on GNU linkers, relevant to MS tools
APP_CXXLINK_FLAGS_NORANDOM = $(APP_CXXLINK_FLAGS)

ifeq ($(OVERRIDE_DEFAULT_COMPILER),1)
    # We override CXX only if it is the default one from Make.
    # Environment overrides of CXX take precidence.

    ifeq ($(TARGET_OS),l)
        ifeq ($(origin CC), default)
            CC = /usr/intel/pkgs/gcc/4.3.1/bin/gcc
        endif
        ifeq ($(origin CXX), default)
            CXX = /usr/intel/pkgs/gcc/4.3.1/bin/g++
        endif
    endif

    ifeq ($(TARGET_OS),b)
        ifeq ($(origin CC), default)
            CC = /usr/local/bin/gcc43
        endif
        ifeq ($(origin CXX), default)
            CXX = /usr/local/bin/g++43
        endif
    endif

    ifeq ($(TARGET_OS),m)
        ifeq ($(origin CC), default)
            CC = /usr/bin/clang
        endif
        ifeq ($(origin CXX), default)
            CXX = /usr/bin/clang++
        endif
    endif
endif

# Pin-probe runtime doesn't support the new GNU_HASH style
# First check if the linker used to build the tools support the flag --hash-style.
# In this case set the hash-style to be the old (SYSV) style
HELPOUT=$(shell $(CC) -v --help 2>&1)
ifneq ($(findstring --hash-style,$(HELPOUT)),)
    PIN_LDFLAGS += -Wl,--hash-style=sysv
endif

# GLIBC version 2.4 implements the function __stack_chk_fail used by new GCC
# versions when stack-protector is on. Therefore, disable this option (if supported)
ifneq ($(findstring stack-protector,$(HELPOUT)),)
    PIN_CXXFLAGS += -fno-stack-protector
endif

##############################################################
# Set the architecture specific stuff
##############################################################

ifeq ($(TARGET),ia32)

PIN_CXXFLAGS += -DTARGET_IA32 -DHOST_IA32
APP_CXXFLAGS += -DTARGET_IA32 -DFUND_TC_HOSTCPU=FUND_CPU_IA32 -DFUND_TC_TARGETCPU=FUND_CPU_IA32
APP_CXXFLAGS2 += -DTARGET_IA32 -DFUND_TC_HOSTCPU=FUND_CPU_IA32 -DFUND_TC_TARGETCPU=FUND_CPU_IA32
PIN_XED_LIBS = -lxed
PIN_BASE_LIBS += -lxed
PIN_BASE_LIBS_SA += -lxed
ifeq ($(TARGET_OS),m)
PIN_PTHREAD_LIBS = -lpinpthread
else
### TOOLADDR setting for Linux and Windows
TOOLADDR = -Wl,--section-start,.interp=0x06048400
PIN_PTHREAD_LIBS = -lpinpthread
PIN_PTHREAD_LIBS_FLAGS = -Wl,-u,__pthread_mutex_init
endif
endif

ifeq ($(TARGET),ia32)
   ifeq (${HOST_ARCH},ia32e)
        ### IA32 on Intel64 compiler flags
        PIN_CXXFLAGS += -m32
        PIN_LDFLAGS += -m32
        PIN_LD_MACHINE_FLAGS = -m32
        ASLD_FLAGS = -m elf_i386
        AS_FLAGS = --32
        TESTAPP = $(PIN_KIT)/source/tools/Utils/$(OBJDIR)cp-pin
        APP_CXXFLAGS += -m32
        APP_CXXFLAGS2 += -m32
        CC += -m32
        CXX += -m32
    endif
endif

ifeq ($(TARGET),ia32e)
    PIN_CXXFLAGS += -DTARGET_IA32E -DHOST_IA32E
    APP_CXXFLAGS += -DTARGET_IA32E -DFUND_TC_HOSTCPU=FUND_CPU_INTEL64 -DFUND_TC_TARGETCPU=FUND_CPU_INTEL64
    APP_CXXFLAGS2 += -DTARGET_IA32E -DFUND_TC_HOSTCPU=FUND_CPU_INTEL64 -DFUND_TC_TARGETCPU=FUND_CPU_INTEL64
    PIN_XED_LIBS = -lxed
    PIN_BASE_LIBS += -lxed
    PIN_BASE_LIBS_SA += -lxed
    ifeq ($(TARGET_OS),b)
        # FreeBSD
        TOOLADDR = -Wl,--section-start,.interp=0x60000190
    else
        # Linux
        PIN_PTHREAD_LIBS = -lpinpthread
        PIN_PTHREAD_LIBS_FLAGS = -Wl,-u,__pthread_mutex_init
        TOOLADDR = -Wl,--section-start,.interp=0x20048000
    endif
endif

ifeq ($(TARGET),mic)
    PIN_CXXFLAGS += -DTARGET_MIC -DHOST_MIC
    APP_CXXFLAGS += -DTARGET_MIC -DFUND_TC_HOSTCPU=FUND_CPU_MIC -DFUND_TC_TARGETCPU=FUND_CPU_MIC
    APP_CXXFLAGS2 += -DTARGET_MIC -DFUND_TC_HOSTCPU=FUND_CPU_MIC -DFUND_TC_TARGETCPU=FUND_CPU_MIC
    PIN_BASE_LIBS += -lxed
    PIN_BASE_LIBS_SA += -lxed

    # Linux is currently the only supported OS on MIC
    PIN_PTHREAD_LIBS = -lpinpthread
    PIN_PTHREAD_LIBS_FLAGS = -Wl,-u,__pthread_mutex_init
    TOOLADDR = -Wl,--section-start,.interp=0x20048000
endif


ifeq ($(TARGET),ipf)
    PIN_CXXFLAGS += -DTARGET_IPF -DHOST_IPF
    APP_CXXFLAGS += -DTARGET_IPF -DFUND_TC_HOSTCPU=FUND_CPU_IA64 -DFUND_TC_TARGETCPU=FUND_CPU_IA64
    APP_CXXFLAGS2 += -DTARGET_IPF -DFUND_TC_HOSTCPU=FUND_CPU_IA64 -DFUND_TC_TARGETCPU=FUND_CPU_IA64
    TOOLADDR = -Wl,--section-start,.interp=0x00000c0000000400,--section-start,.init_array=0x00000e0000000400,-defsym,__init_array_start=0x00000e0000000400,-defsym,__preinit_array_start=__init_array_start,-defsym,__preinit_array_end=__preinit_array_start
    PIN_PTHREAD_LIBS = -lpinpthread
    PIN_PTHREAD_LIBS_FLAGS = -Wl,-u,__pthread_mutex_init
endif

##############################################################
# Set the OS specific variables
#   Some of this refers to architecture dependent variables
#   so this must second
##############################################################

# Select tools to be shared objects on Linux
# Use ?= to allow the user to override it in the command line
ifeq ($(TARGET_OS),l)
    SOTOOL ?= 1
endif
ifeq ($(TARGET_OS),b)
    SOTOOL ?= 1
endif
ifeq ($(TARGET_OS),m)
    SOTOOL ?= 1
endif

ifeq ($(TARGET_OS),w)
### Windows
    PIN_CXXFLAGS += -DTARGET_WINDOWS -mno-cygwin

    #FIXME: make this conditional based on the compiler
    PIN_BASE_LIBS +=  -lpinvm -lntdll
    PIN_LDFLAGS += -Wl,--export-all-symbols
    PIN_LDFLAGS += -shared -Wl,-wrap,atexit,-wrap,_onexit,-e,_Ptrace_DllMainCRTStartup@12 -mno-cygwin
    PIN_LDFLAGS += -Wl,--image-base -Wl,0x55000000
    PINTOOL_SUFFIX = .dll
    ifndef TESTAPP
      TESTAPP = $(PIN_HOME)/Tests/$(OBJDIR)cp-pin.exe
    endif
    APP_CXXFLAGS += -DTARGET_WINDOWS -mno-cygwin -DFUND_TC_HOSTOS=FUND_OS_WINDOWS -DFUND_TC_TARGETOS=FUND_OS_WINDOWS
    PIN_CMP = cmp
    PIN_DIFF = diff -w
    APP_CXXFLAGS2 += -mno-cygwin
    EXEEXT = .exe
    SHLIBEXT = .dll
    OBJEXT = obj
else
### Linux or Mac or FreeBSD
  ifeq ($(TARGET_OS),m)
    PIN_CMP = ../mac-cmp
  else
    PIN_CMP = cmp
  endif
  PIN_DIFF = ${PIN_CMP}
  ifeq ($(TARGET_OS),b)
    # on FreeBSD we currently support only libthr as libpthread uses KSE
    APP_PTHREAD=-lthr
  else
    APP_PTHREAD=-lpthread
  endif
  ifndef TESTAPP
    # TESTAPP = /bin/cp
    TESTAPP = $(PIN_KIT)/source/tools/Utils/$(OBJDIR)cp-pin.exe
  endif

  ifeq ($(SOTOOL),1)
### Unix (tool is shared object)

    # If the native compiler and binutils are too new, we must link the tools with older
    # version of binutils to test tools in probe mode. To do that we put their directory
    # in the front of the PATH environment variable.
    ifdef BINUTILS_PATH
        PIN_LD = env PATH=$(BINUTILS_PATH):$(PATH) $(CXX)
    endif

    # on intel64 and ipf shared-objects must be compiled with -fPIC
    ifneq ($(TARGET),ia32)
      PIN_CXXFLAGS += -fPIC
    endif

    ifeq ($(TARGET_OS),l)
        PIN_CXXFLAGS += -DTARGET_LINUX
        APP_CXXFLAGS += -DTARGET_LINUX -DFUND_TC_HOSTOS=FUND_OS_LINUX -DFUND_TC_TARGETOS=FUND_OS_LINUX
        PIN_BASE_LIBS += -ldwarf -lelf ${PIN_DYNAMIC}
        PIN_BASE_LIBS_SA += -Wl,-Bstatic -ldwarf -lelf -Wl,-Bdynamic ${PIN_DYNAMIC}
        PIN_SOFLAGS = -shared -Wl,-Bsymbolic -Wl,--version-script=$(VSCRIPT_DIR)/pintool.ver
    endif
    ifeq ($(TARGET_OS),b)
        PIN_CXXFLAGS += -DTARGET_BSD
        APP_CXXFLAGS += -DTARGET_BSD -DFUND_TC_HOSTOS=FUND_OS_BSD -DFUND_TC_TARGETOS=FUND_OS_BSD
        PIN_BASE_LIBS += -ldwarf -lelf
        PIN_BASE_LIBS_SA += -ldwarf -lelf
        PIN_SOFLAGS = -shared -Wl,-Bsymbolic -Wl,--version-script=$(VSCRIPT_DIR)/pintool.ver
    endif
    ifeq ($(TARGET_OS),m)
        PIN_CXXFLAGS += -DTARGET_MAC
        APP_CXXFLAGS += -DTARGET_MAC -DFUND_TC_HOSTOS=FUND_OS_MAC -DFUND_TC_TARGETOS=FUND_OS_MAC
        APP_CXXFLAGS2 += -DTARGET_MAC -DFUND_TC_HOSTOS=FUND_OS_MAC -DFUND_TC_TARGETOS=FUND_OS_MAC
        PIN_SOFLAGS = -w -shared -Wl,-exported_symbols_list -Wl,$(VSCRIPT_DIR)/pintool.exp
    endif

    ifeq ($(TARGET_OS),m)
        PINTOOL_SUFFIX=.dylib
        SHLIBEXT=.dylib
    else
        PINTOOL_SUFFIX=.so
        SHLIBEXT=.so
    endif

    # shared object tool don't need TOOLADDR
    SATOOL_SUFFIX=
    TOOLADDR =
    EXEEXT=
    OBJEXT=o
    PIN_SALDFLAGS := $(PIN_LDFLAGS)
    PIN_LDFLAGS += $(PIN_SOFLAGS)
  else
### Linux or Mac or FreeBSD (tool is executable)

    ifeq ($(TARGET_OS),l)
        ### Linux
        PIN_BASE_LIBS += -ldwarf -lelf ${PIN_DYNAMIC}
        PIN_BASE_LIBS_SA += -Wl,-Bstatic -ldwarf -lelf -Wl,-Bdynamic ${PIN_DYNAMIC}
        PIN_CXXFLAGS += -DTARGET_LINUX
        PIN_LDFLAGS += -Wl,-u,malloc
        APP_CXXFLAGS += -DTARGET_LINUX -DFUND_TC_HOSTOS=FUND_OS_LINUX -DFUND_TC_TARGETOS=FUND_OS_LINUX
    else
        ifeq ($(TARGET_OS),b)
            ### FreeBSD
            PIN_BASE_LIBS += -ldwarf -lelf
            PIN_BASE_LIBS_SA += -ldwarf -lelf
            PIN_CXXFLAGS += -DTARGET_BSD
            PIN_LDFLAGS += -Wl,-u,malloc
            APP_CXXFLAGS += -DTARGET_BSD -DFUND_TC_HOSTOS=FUND_OS_BSD -DFUND_TC_TARGETOS=FUND_OS_BSD
        else
            ifeq ($(TARGET_OS),m)
                ### Mac
                # This enables the thread safe libc by pulling in pthread.o from libpinpthread.a
                # Otherwise, you will get the non threadsafe version from libc
                # It also pulls in malloc_st.o by using malloc

                PIN_BASE_LIBS += $(PIN_PTHREAD_LIBS) ${PIN_DYNAMIC}
                PIN_LDFLAGS += $(PIN_PTHREAD_LIBS_FLAGS)

                # The -lpinpthreads library refers to symbols in -lpin / -lsapin, so
                # add them a second time on the link line.
                PIN_BASE_LIBS_MAC = -lpin
                PIN_BASE_LIBS_MAC_SA = -lsapin

                # Suppress linker warnings
                PIN_LDFLAGS += -w -Wl,-multiply_defined -Wl,suppress
                PIN_CXXFLAGS += -DTARGET_MAC
                APP_CXXFLAGS += -DTARGET_MAC -DFUND_TC_HOSTOS=FUND_OS_MAC -DFUND_TC_TARGETOS=FUND_OS_MAC
                APP_CXXFLAGS2 += -DTARGET_MAC -DFUND_TC_HOSTOS=FUND_OS_MAC -DFUND_TC_TARGETOS=FUND_OS_MAC
           endif
        endif
    endif

    ifeq ($(TARGET_OS),m)
        SHLIBEXT=.dylib
    else
        SHLIBEXT=.so
    endif

    PIN_SALDFLAGS := $(PIN_LDFLAGS)      # static analysis tools don't need TOOLADDR
    PIN_LDFLAGS += ${TOOLADDR}
    PINTOOL_SUFFIX =
    SATOOL_SUFFIX =
    EXEEXT =
    OBJEXT = o
  endif
endif

PIN_LD ?= $(CXX)

ifeq ($(PIN_PIE),1)
  ifneq ($(SOTOOL),1)
    PIN_CXXFLAGS += -fPIE
    PIN_LDFLAGS += -pie -Wl,-Bsymbolic
    TOOLADDR =
  endif
endif

SAPIN_LIBS = -lsapin $(PIN_BASE_LIBS_SA) $(PIN_BASE_LIBS_MAC_SA)
PIN_LIBS = -lpin $(PIN_BASE_LIBS) $(PIN_BASE_LIBS_MAC)

##############################################################
# Some final variables
##############################################################
# can set these so that apps are compiled with different compiler than tools
APP_CXX=$(CXX)
APP_CC=$(CC)
# put the lpaths before all the libs
PIN_LDFLAGS +=  ${PIN_LPATHS}
PIN_CXXFLAGS_NOOPT := $(PIN_CXXFLAGS)
PIN_CXXFLAGS += $(OPT)
NO_OPTIMIZE  = -O0
COPT         = -c -std=c++11
OUTOPT       = -o
OUTEXE       = -o
LINK_OUT     = -o


OBJDIR = obj-$(TARGET_LONG)/
PYTHON = python

##############################################################
# Rules to make testing easier
# This testing only checks that the application ran correctly.
# It does no checking of the results of the tool.
# If you make the tool self checking and exit with a non zero exit code,
# then it will detect the error
# Before the test, we make a .tested and a .failed file. If
# the test succeeds, we remove the .failed file.
# find . -name '*.tested'
# and
# find . -name '*.failed'
# will summarize what you tested and what failed
##############################################################
%.test: $(OBJDIR)

%$(PINTOOL_SUFFIX).test : $(OBJDIR)%$(PINTOOL_SUFFIX) %.tested %.failed
	touch $<.makefile.copy; rm $<.makefile.copy
	$(PIN) -t $< -- $(TESTAPP) makefile $<.makefile.copy
	$(PIN_CMP) makefile $<.makefile.copy
	rm $<.makefile.copy; rm $(@:$(PINTOOL_SUFFIX).test=.failed)

# Some subdirectories do not want the $(PINTOOL_SUFFIX) in their test name.
%.test : $(OBJDIR)%$(PINTOOL_SUFFIX) %.tested %.failed
	touch $<.makefile.copy; rm $<.makefile.copy
	$(PIN) -t $< -- $(TESTAPP) makefile $<.makefile.copy
	$(PIN_CMP) makefile $<.makefile.copy
	rm $<.makefile.copy; rm $(@:.test=.failed)


%.tested :
	touch $@

%.failed :
	touch $@

# otherwise these are deleted if the tool build fails
.PRECIOUS : %.tested %.failed

all:

.PHONY: dir
dir:
	mkdir -p $(OBJDIR)
